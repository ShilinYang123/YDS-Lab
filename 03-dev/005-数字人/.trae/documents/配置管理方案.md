# 数字员工项目配置管理方案

## 1. 概述

本方案旨在为数字员工项目提供统一、灵活、安全的配置管理体系，支持多环境部署、动态配置更新、敏感信息保护等功能。

## 2. 设计原则

### 2.1 统一配置
- 所有配置集中管理
- 统一配置格式和标准
- 支持配置继承和覆盖

### 2.2 环境隔离
- 开发、测试、生产环境完全隔离
- 环境配置互不干扰
- 支持本地开发配置

### 2.3 安全保护
- 敏感信息加密存储
- 访问权限控制
- 配置审计日志

### 2.4 动态更新
- 支持运行时配置更新
- 配置变更通知机制
- 热重载支持

## 3. 配置架构

### 3.1 配置层次结构

```
默认配置 (config/default/)
    ↓
环境配置 (config/{environment}/)
    ↓
本地配置 (config/local/)
    ↓
运行时配置 (环境变量/命令行参数)
```

### 3.2 配置文件结构

```
config/
├── default/                    # 默认配置
│   ├── application.yml          # 应用配置
│   ├── database.yml           # 数据库配置
│   ├── redis.yml              # Redis配置
│   ├── minio.yml              # MinIO配置
│   ├── security.yml           # 安全配置
│   └── logging.yml            # 日志配置
├── development/                # 开发环境
│   ├── application.yml
│   ├── database.yml
│   ├── redis.yml
│   ├── minio.yml
│   ├── security.yml
│   └── logging.yml
├── production/                 # 生产环境
│   ├── application.yml
│   ├── database.yml
│   ├── redis.yml
│   ├── minio.yml
│   ├── security.yml
│   └── logging.yml
├── local/                      # 本地配置
│   └── *.yml                   # 本地覆盖配置
└── secrets/                    # 敏感配置（加密）
    ├── database.enc.yml
    ├── api-keys.enc.yml
    └── certificates/
```

## 4. 配置管理器设计

### 4.1 Python配置管理器

```python
# config/manager.py
import os
import yaml
from typing import Dict, Any, Optional
from pathlib import Path
import json
from cryptography.fernet import Fernet

class ConfigManager:
    """统一配置管理器"""
    
    def __init__(self, config_dir: str = "config", environment: str = None):
        self.config_dir = Path(config_dir)
        self.environment = environment or os.getenv('ENVIRONMENT', 'development')
        self.config_cache = {}
        self.encryption_key = self._get_encryption_key()
        self._load_all_configs()
    
    def _get_encryption_key(self) -> Optional[bytes]:
        """获取加密密钥"""
        key = os.getenv('CONFIG_ENCRYPTION_KEY')
        if key:
            return key.encode()
        return None
    
    def _load_all_configs(self):
        """加载所有配置文件"""
        # 加载默认配置
        self._load_config_files('default')
        
        # 加载环境配置
        self._load_config_files(self.environment)
        
        # 加载本地配置
        self._load_config_files('local')
        
        # 加载敏感配置
        self._load_secret_configs()
        
        # 加载环境变量
        self._load_environment_variables()
    
    def _load_config_files(self, config_type: str):
        """加载指定类型的配置文件"""
        config_path = self.config_dir / config_type
        if not config_path.exists():
            return
        
        for config_file in config_path.glob('*.yml'):
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    config_data = yaml.safe_load(f)
                    if config_data:
                        self._merge_config(self.config_cache, config_data)
            except Exception as e:
                print(f"Warning: Failed to load {config_file}: {e}")
    
    def _load_secret_configs(self):
        """加载敏感配置（解密）"""
        secrets_path = self.config_dir / 'secrets'
        if not secrets_path.exists() or not self.encryption_key:
            return
        
        cipher = Fernet(self.encryption_key)
        
        for secret_file in secrets_path.glob('*.enc.yml'):
            try:
                with open(secret_file, 'rb') as f:
                    encrypted_data = f.read()
                    decrypted_data = cipher.decrypt(encrypted_data)
                    config_data = yaml.safe_load(decrypted_data.decode())
                    if config_data:
                        self._merge_config(self.config_cache, config_data)
            except Exception as e:
                print(f"Warning: Failed to decrypt {secret_file}: {e}")
    
    def _load_environment_variables(self):
        """加载环境变量配置"""
        # 支持前缀为APP_的环境变量
        env_config = {}
        for key, value in os.environ.items():
            if key.startswith('APP_'):
                # APP_DATABASE_HOST -> database.host
                config_key = key[4:].lower().replace('_', '.')
                self._set_nested_value(env_config, config_key, value)
        
        self._merge_config(self.config_cache, env_config)
    
    def _merge_config(self, base: Dict, update: Dict):
        """合并配置字典"""
        for key, value in update.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_config(base[key], value)
            else:
                base[key] = value
    
    def _set_nested_value(self, config: Dict, key_path: str, value: Any):
        """设置嵌套配置值"""
        keys = key_path.split('.')
        current = config
        
        for key in keys[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]
        
        # 尝试转换值类型
        current[keys[-1]] = self._convert_value(value)
    
    def _convert_value(self, value: str) -> Any:
        """转换配置值类型"""
        # 布尔值
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'
        
        # 数字
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            pass
        
        # JSON
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            pass
        
        # 字符串
        return value
    
    def get(self, key_path: str, default: Any = None) -> Any:
        """获取配置值"""
        keys = key_path.split('.')
        current = self.config_cache
        
        try:
            for key in keys:
                current = current[key]
            return current
        except KeyError:
            return default
    
    def set(self, key_path: str, value: Any):
        """设置配置值（运行时）"""
        self._set_nested_value(self.config_cache, key_path, value)
    
    def reload(self):
        """重新加载配置"""
        self.config_cache.clear()
        self._load_all_configs()
    
    def export_config(self) -> Dict[str, Any]:
        """导出完整配置"""
        return self.config_cache.copy()

# 全局配置管理器实例
config_manager = ConfigManager()

# 便捷函数
def get_config(key_path: str, default: Any = None) -> Any:
    """获取配置值"""
    return config_manager.get(key_path, default)

def set_config(key_path: str, value: Any):
    """设置配置值"""
    config_manager.set(key_path, value)

def reload_config():
    """重新加载配置"""
    config_manager.reload()
```

### 4.2 配置验证器

```python
# config/validator.py
from typing import Dict, Any, List
import re
from datetime import timedelta

class ConfigValidator:
    """配置验证器"""
    
    def __init__(self):
        self.validation_rules = {
            'database': {
                'host': {'type': str, 'required': True},
                'port': {'type': int, 'required': True, 'min': 1, 'max': 65535},
                'username': {'type': str, 'required': True},
                'password': {'type': str, 'required': True},
                'database': {'type': str, 'required': True},
                'pool_size': {'type': int, 'min': 1, 'max': 100},
                'timeout': {'type': int, 'min': 1, 'max': 300}
            },
            'redis': {
                'host': {'type': str, 'required': True},
                'port': {'type': int, 'required': True, 'min': 1, 'max': 65535},
                'password': {'type': str},
                'database': {'type': int, 'min': 0, 'max': 15},
                'max_connections': {'type': int, 'min': 1, 'max': 1000}
            },
            'minio': {
                'endpoint': {'type': str, 'required': True},
                'access_key': {'type': str, 'required': True},
                'secret_key': {'type': str, 'required': True},
                'bucket': {'type': str, 'required': True},
                'secure': {'type': bool}
            },
            'security': {
                'jwt_secret': {'type': str, 'required': True, 'min_length': 32},
                'jwt_expires_in': {'type': str, 'pattern': r'^\d+[smhd]$'},
                'cors_origins': {'type': list},
                'rate_limit': {'type': int, 'min': 1, 'max': 10000}
            },
            'logging': {
                'level': {'type': str, 'choices': ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']},
                'format': {'type': str},
                'file': {'type': str},
                'max_size': {'type': int, 'min': 1048576},
                'backup_count': {'type': int, 'min': 1, 'max': 100}
            }
        }
    
    def validate(self, config: Dict[str, Any]) -> List[str]:
        """验证配置"""
        errors = []
        
        for section, rules in self.validation_rules.items():
            if section not in config:
                errors.append(f"Missing required section: {section}")
                continue
            
            section_errors = self._validate_section(config[section], rules)
            errors.extend(section_errors)
        
        return errors
    
    def _validate_section(self, section_config: Dict[str, Any], rules: Dict[str, Any]) -> List[str]:
        """验证配置段"""
        errors = []
        
        for field, rule in rules.items():
            if field not in section_config:
                if rule.get('required', False):
                    errors.append(f"Missing required field: {field}")
                continue
            
            value = section_config[field]
            field_errors = self._validate_field(value, field, rule)
            errors.extend(field_errors)
        
        return errors
    
    def _validate_field(self, value: Any, field_name: str, rule: Dict[str, Any]) -> List[str]:
        """验证字段"""
        errors = []
        
        # 类型检查
        expected_type = rule.get('type')
        if expected_type and not isinstance(value, expected_type):
            errors.append(f"Field {field_name} must be of type {expected_type.__name__}")
            return errors
        
        # 数值范围检查
        if isinstance(value, (int, float)):
            if 'min' in rule and value < rule['min']:
                errors.append(f"Field {field_name} must be >= {rule['min']}")
            if 'max' in rule and value > rule['max']:
                errors.append(f"Field {field_name} must be <= {rule['max']}")
        
        # 字符串长度检查
        if isinstance(value, str):
            if 'min_length' in rule and len(value) < rule['min_length']:
                errors.append(f"Field {field_name} must be at least {rule['min_length']} characters long")
            if 'max_length' in rule and len(value) > rule['max_length']:
                errors.append(f"Field {field_name} must be at most {rule['max_length']} characters long")
            
            # 正则表达式检查
            if 'pattern' in rule:
                if not re.match(rule['pattern'], value):
                    errors.append(f"Field {field_name} does not match required pattern")
            
            # 选项检查
            if 'choices' in rule:
                if value not in rule['choices']:
                    errors.append(f"Field {field_name} must be one of {rule['choices']}")
        
        # 列表检查
        if isinstance(value, list):
            if 'item_type' in rule:
                for item in value:
                    if not isinstance(item, rule['item_type']):
                        errors.append(f"All items in {field_name} must be of type {rule['item_type'].__name__}")
                        break
        
        return errors
```

## 5. 配置加密方案

### 5.1 加密工具

```python
# config/encryption.py
from cryptography.fernet import Fernet
import os
import base64
from typing import Optional

class ConfigEncryption:
    """配置加密工具"""
    
    def __init__(self, key: Optional[str] = None):
        if key:
            self.key = key.encode()
        else:
            self.key = self._generate_or_load_key()
        
        self.cipher = Fernet(self.key)
    
    def _generate_or_load_key(self) -> bytes:
        """生成或加载加密密钥"""
        key_file = "config/.encryption_key"
        
        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            # 生成新密钥
            key = Fernet.generate_key()
            # 确保目录存在
            os.makedirs(os.path.dirname(key_file), exist_ok=True)
            # 保存密钥
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        encrypted = self.cipher.encrypt(data.encode())
        return base64.b64encode(encrypted).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        encrypted_bytes = base64.b64decode(encrypted_data.encode())
        decrypted = self.cipher.decrypt(encrypted_bytes)
        return decrypted.decode()
    
    def encrypt_file(self, input_file: str, output_file: str):
        """加密文件"""
        with open(input_file, 'r', encoding='utf-8') as f:
            data = f.read()
        
        encrypted_data = self.encrypt(data)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(encrypted_data)
    
    def decrypt_file(self, input_file: str, output_file: str):
        """解密文件"""
        with open(input_file, 'r', encoding='utf-8') as f:
            encrypted_data = f.read()
        
        decrypted_data = self.decrypt(encrypted_data)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(decrypted_data)
```

## 6. 使用示例

### 6.1 基本使用

```python
from config.manager import get_config, set_config

# 获取数据库配置
db_host = get_config('database.host', 'localhost')
db_port = get_config('database.port', 5432)

# 获取Redis配置
redis_url = get_config('redis.url')

# 获取安全配置
jwt_secret = get_config('security.jwt_secret')

# 设置运行时配置
set_config('app.debug', True)
```

### 6.2 配置验证

```python
from config.manager import config_manager
from config.validator import ConfigValidator

# 获取完整配置
config = config_manager.export_config()

# 验证配置
validator = ConfigValidator()
errors = validator.validate(config)

if errors:
    print("配置验证失败：")
    for error in errors:
        print(f"  - {error}")
else:
    print("配置验证通过")
```

### 6.3 配置加密

```python
from config.encryption import ConfigEncryption

# 创建加密工具
encryption = ConfigEncryption()

# 加密敏感配置
secret_config = """
database:
  password: "my_secret_password"
api_keys:
  openai: "sk-xxxxxxxxxxxxxxxx"
"""

# 加密文件
encryption.encrypt_file('secrets/raw-config.yml', 'secrets/config.enc.yml')

# 解密文件
encryption.decrypt_file('secrets/config.enc.yml', 'secrets/decrypted-config.yml')
```

## 7. 环境变量映射

### 7.1 映射规则

环境变量前缀：`APP_`

映射示例：
- `APP_DATABASE_HOST` → `database.host`
- `APP_REDIS_PORT` → `redis.port`
- `APP_SECURITY_JWT_SECRET` → `security.jwt_secret`

### 7.2 类型转换

自动类型转换：
- `true/false` → 布尔值
- `123` → 整数
- `123.45` → 浮点数
- `{"key": "value"}` → JSON对象
- 其他 → 字符串

## 8. 配置热重载

### 8.1 文件监控

```python
# config/hot_reload.py
import time
import os
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class ConfigHotReloadHandler(FileSystemEventHandler):
    """配置热重载处理器"""
    
    def __init__(self, config_manager, callback=None):
        self.config_manager = config_manager
        self.callback = callback
    
    def on_modified(self, event):
        if event.is_directory:
            return
        
        if event.src_path.endswith(('.yml', '.yaml')):
            print(f"配置文件已修改: {event.src_path}")
            self.config_manager.reload()
            
            if self.callback:
                self.callback()

class ConfigHotReloader:
    """配置热重载器"""
    
    def __init__(self, config_manager, config_dir: str = "config"):
        self.config_manager = config_manager
        self.config_dir = Path(config_dir)
        self.observer = None
    
    def start(self, callback=None):
        """开始监控配置变化"""
        event_handler = ConfigHotReloadHandler(self.config_manager, callback)
        self.observer = Observer()
        self.observer.schedule(event_handler, str(self.config_dir), recursive=True)
        self.observer.start()
        print("配置热重载已启动")
    
    def stop(self):
        """停止监控"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            print("配置热重载已停止")
```

## 9. 最佳实践

### 9.1 配置组织

1. **按功能模块组织配置**
2. **使用有意义的配置键名**
3. **提供配置注释和文档**
4. **使用配置模板**

### 9.2 安全配置

1. **敏感信息必须加密**
2. **定期轮换加密密钥**
3. **限制配置访问权限**
4. **记录配置访问日志**

### 9.3 版本管理

1. **配置文件纳入版本控制**
2. **敏感配置使用加密文件**
3. **提供配置变更历史**
4. **支持配置回滚**

### 9.4 部署建议

1. **不同环境使用不同配置**
2. **生产配置严格验证**
3. **配置变更需要审批**
4. **监控配置变更影响**

## 10. 监控和审计

### 10.1 配置访问日志

```python
# 记录配置访问
import logging
import time

config_logger = logging.getLogger('config')

def log_config_access(action: str, key: str, value: Any = None):
    """记录配置访问日志"""
    config_logger.info({
        'timestamp': time.time(),
        'action': action,
        'key': key,
        'value': str(value) if value else None,
        'user': os.getenv('USER', 'system')
    })
```

### 10.2 配置变更通知

```python
# 配置变更通知
def notify_config_change(key: str, old_value: Any, new_value: Any):
    """通知配置变更"""
    # 发送邮件通知
    # 发送到监控系统
    # 记录变更历史
    pass
```

这个配置管理方案提供了完整的配置生命周期管理，从配置创建、验证、加密、使用到监控，确保配置的安全性、可维护性和可扩展性。